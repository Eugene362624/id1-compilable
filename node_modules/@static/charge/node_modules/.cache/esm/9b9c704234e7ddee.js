let parseURL,pathResolve,pathJoin,existsSync,readFileSync,BrowserSync,logger,build;_34e‍.x([["default",()=>_34e‍.o]]);_34e‍.w("url",[["parse",["parseURL"],function(v){parseURL=v}]]);_34e‍.w("path",[["resolve",["pathResolve"],function(v){pathResolve=v}],["join",["pathJoin"],function(v){pathJoin=v}]]);_34e‍.w("fs",[["existsSync",["existsSync"],function(v){existsSync=v}],["readFileSync",["readFileSync"],function(v){readFileSync=v}]]);_34e‍.w("browser-sync",[["default",["BrowserSync"],function(v){BrowserSync=v}]]);_34e‍.w("./logger",[["default",["logger"],function(v){logger=v}]]);_34e‍.w("./build",[["default",["build"],function(v){build=v}]]);






const fileIsData = (path) => {
  return path.startsWith("data/")
}

const fileIsAddedOrRemoved = (event) => {
  return ["add", "unlink", "addDir", "unlinkDir"].includes(event)
}

const fileIsChanged = (event) => {
  return event === "change"
}

const _34e‍anonymous=async ({ source, openBrowser = true, port = 2468 }) => {
  let target = pathResolve("tmp/target")

  logger.builder.start(`Building static files from ${source}`)

  await build({
    source,
    target,
    environment: "development",
  })

  logger.builder.done(`Static files built!`)

  let redirectWithoutTrailingSlash = (request, response, next) => {
    let url = parseURL(request.url)
    let path = url.path

    let pathHasTrailingSlash = path !== "/" && path.endsWith("/")

    if (pathHasTrailingSlash) {
      response.statusCode = 302
      response.setHeader("Location", path.slice(0, -1))
      response.end()
      return
    } else {
      next()
    }
  }

  let tryDirectoryIndex = (request, response, next) => {
    let url = parseURL(request.url)
    let path = url.path
    let filePath = pathJoin(target, `${path}.html`)

    if (existsSync(filePath)) {
      response.statusCode = 200
      response.setHeader("Content-Type", "text/html; charset=UTF-8")
      response.end(readFileSync(filePath).toString())
    } else {
      next()
    }
  }

  let notFound = (request, response) => {
    let url = parseURL(request.url)
    let path = url.path
    let filePath = pathJoin(target, path)

    response.statusCode = 404
    response.setHeader("Content-Type", "text/plain")
    response.end(`File ${filePath} not found!`)
  }

  let browserSync = BrowserSync.create()

  logger.watcher.start(source)

  let sourceGlob = `${source}/**/*`
  let dataGlob = `data/*.json`

  browserSync.watch([sourceGlob, dataGlob], { ignoreInitial: true }, async (event, file) => {
    if (fileIsAddedOrRemoved(event) || fileIsData(file)) {
      await build({
        source,
        target,
        file: null,
        environment: "development",
      })

      logger.browser.reload()

      browserSync.reload()
    } else if (fileIsChanged(event)) {
      let filePaths = await build({
        source,
        target,
        file,
        environment: "development",
      })

      logger.browser.reload()

      browserSync.reload(filePaths)
    }
  })

  return new Promise((resolve) => {
    browserSync.init(
      {
        logLevel: "silent",
        middleware: [redirectWithoutTrailingSlash, tryDirectoryIndex],
        open: openBrowser,
        port: port,
        server: {
          baseDir: target,
        },
      },
      (error, browserSyncInstance) => {
        let actualPort = browserSyncInstance.options.get("port")
        browserSyncInstance.addMiddleware("*", notFound)

        logger.server.start(`Running on port ${actualPort}`)
        logger.browser.open(`Opening http://localhost:${actualPort}`)

        resolve(browserSyncInstance)
      },
    )
  })
};_34e‍.d(_34e‍anonymous);
