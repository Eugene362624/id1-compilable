let globSync,globSyncNormalize,pathParse,pathResolve,pathJoin,pathSeparator,emptyDirSync,readFileSync,outputFileSync,flatMap,uniqBy,logger,File,React,importComponent;_34e‍.x([["default",()=>_34e‍.o]]);_34e‍.w("./utilities",[["globSync",["globSync"],function(v){globSync=v}],["globSyncNormalize",["globSyncNormalize"],function(v){globSyncNormalize=v}],["importComponent",["importComponent"],function(v){importComponent=v}]]);_34e‍.w("path",[["parse",["pathParse"],function(v){pathParse=v}],["resolve",["pathResolve"],function(v){pathResolve=v}],["join",["pathJoin"],function(v){pathJoin=v}],["sep",["pathSeparator"],function(v){pathSeparator=v}]]);_34e‍.w("fs-extra",[["emptyDirSync",["emptyDirSync"],function(v){emptyDirSync=v}],["readFileSync",["readFileSync"],function(v){readFileSync=v}],["outputFileSync",["outputFileSync"],function(v){outputFileSync=v}]]);_34e‍.w("lodash.flatmap",[["default",["flatMap"],function(v){flatMap=v}]]);_34e‍.w("lodash.uniqby",[["default",["uniqBy"],function(v){uniqBy=v}]]);_34e‍.w("./logger",[["default",["logger"],function(v){logger=v}]]);_34e‍.w("./file",[["default",["File"],function(v){File=v}]]);_34e‍.w("react",[["default",["React"],function(v){React=v}]]);














// These need to be required here. The modules aren’t used here but requiring them
// registers their types on the File module so the proper class can be found.
globSync(`${__dirname}/files/*`).forEach((module) => require(module))

let loadData = (source) => {
  let dataDirectory = pathResolve(`${source}/../data`)
  let dataFiles = globSyncNormalize(`${dataDirectory}/*.json`)

  return dataFiles.reduce((data, file) => {
    let fileName = pathParse(file).name
    data[fileName] = JSON.parse(readFileSync(file))
    return data
  }, {})
}

let dependentsOfDependency = (sourceFiles, file) => {
  let sourceFilesThatImportFile = sourceFiles.filter((sourceFile) => {
    try {
      return sourceFile.importedDependencyPaths.includes(file.path)
    } catch (_error) {
      return false
    }
  })

  if (sourceFilesThatImportFile.length) {
    let files = flatMap(sourceFilesThatImportFile, (sourceFileThatImportFile) => {
      return dependentsOfDependency(sourceFiles, sourceFileThatImportFile)
    })

    return uniqBy(files, "path")
  } else {
    return [file]
  }
}

let dependentsThatAreNotDependencies = (sourceFiles) => {
  let importedDependencyPaths = flatMap(sourceFiles, (sourceFile) => {
    try {
      return sourceFile.importedDependencyPaths
    } catch (_error) {
      return []
    }
  })

  return sourceFiles.filter((sourceFile) => {
    return !importedDependencyPaths.includes(sourceFile.path)
  })
}

const _34e‍anonymous=async ({ source, target, file, environment = "production" }) => {
  let files = globSyncNormalize(`${source}/**/*`, {
    nodir: true,
  })

  let sourceFiles = files.map((file) => {
    return File.instantiateByType({
      path: file,
      relativePath: file.replace(source, ""),
    })
  })

  sourceFiles.forEach((sourceFile) => {
    delete require.cache[sourceFile.path]
  })

  let sourceFilesThatCouldBeBuilt = dependentsThatAreNotDependencies(sourceFiles)

  if (file) {
    file = File.instantiateByType({
      path: file,
      relativePath: file.replace(source, ""),
    })

    var sourceFilesToBuild = dependentsOfDependency(sourceFiles, file)
  } else {
    var sourceFilesToBuild = sourceFilesThatCouldBeBuilt

    emptyDirSync(target)
  }

  let data = loadData(source)
  let componentSourceFiles = sourceFilesThatCouldBeBuilt.filter(
    (sourceFile) => sourceFile.isComponent,
  )

  let pages = await Promise.all(
    componentSourceFiles.map(async (sourceFile) => {
      let component = await importComponent(sourceFile.path)
      let outputPath = sourceFile.outputPath

      return {
        component: component.default,
        meta: component.meta || {},
        path:
          outputPath === `${pathSeparator}index.html`
            ? "/"
            : outputPath.replace(/\.html$/, "").replace(/\\/g, "/"),
      }
    }),
  )

  for (const sourceFile of sourceFilesToBuild) {
    try {
      let built = await sourceFile.build({
        data: data,
        environment: environment,
        pages: pages,
      })

      var output = built.output

      logger.builder.building(sourceFile.outputPath)
    } catch (error) {
      error.stack = `${sourceFile.outputPath}\n${error.stack}`
      logger.builder.building(error)
    }

    let fullOutputPath = pathJoin(target, sourceFile.outputPath)

    outputFileSync(fullOutputPath, output)
  }

  return sourceFilesToBuild.map((sourceFile) => sourceFile.outputPath)
};_34e‍.d(_34e‍anonymous);
